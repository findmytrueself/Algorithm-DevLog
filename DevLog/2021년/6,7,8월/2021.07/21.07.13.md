# SSR(Server Side Rendering)

- 서버에서 렌더가 완성 된 상태
- HTML파일이 이미 서버에서 완성.
  장점:

1. 초기 렌딩속도가 빠르다.
2. SEO 최적화가 가능하다.

단점:

1. 페이지를 요청할 때마다 새로고침 된다.
2. 페이지를 이동할 때마다 , 서버에 요청을 보내기 때문에 서버 과부하가 커진다.

# CSR (Client Side Rendering)

- 브라우저에서 렌더가 완성 된 상태
- HTML파일이 클라이언트에서 완성.

장점:

1. 초기 요청을 제외하면, 페이지 전환속도가 빠르다.
2. 서버요청이 적기 때문에 서버 부담이 적다.

단점:

1. 최초 로딩 속도가 느리다.
2. 처음에는 데이터가 존재하지 않기 때문에, SEO에서 문제가 발생함.

# SEO(Search Engine Optimization)

- 웹사이트가 검색 결과에 더 잘 보이도록 최적화하는 과정.(네이버,구글)

# "웹" 기준에서 빌드와 번들링은 같은 의미이다.

BABEL === 트랜스파일러

# Event Propagation

DOM에서 부모엘리먼트 안의 자식엘리먼트는

부모엘리먼트의 이벤트를 상속받는다.

그래서 부모엘리먼트와 자식엘리먼트 동시에 Click 이벤트를 걸고,

자식엘리먼트의 이벤트를 실행시키면, 부모엘리먼트의 이벤트도 동시에 활성화된다.

부모 엘리먼트의 이벤트를 실행시키지 않으려면 ,

e.stopPropagation()
메소드를 쓰면 부모엘리먼트의 이벤트가 실행되지 않는다.

# Event Delegation

부모엘리먼트에만 이벤트를 걸어주고 자식 엘리먼트에서는 조건을 통해 접근한다.

모든 이벤트가 버블업이 되는게 아니다.(클릭이나 키업 같은 이벤트만 된다)

코드를 적게 쓸 수 있고 메모리를 적게 차지 할 수 있다.

# useCallback

props로 전달해야 할 함수를 만들 때는, useCallback을 사용하여 함수를 감싸는 것을 습관화 하자.

# onClick과 onSubmit

onClick 이벤트는 클릭만 구현 가능해서, onKeyPress나 onKeyUp과 같은 이벤트로 Enter키 사용로직을 따로 짜줘야한다.

하지만, <form>과 onSubmit과 e.preventDefault() 메소드로 새로고침을 초기화를 방지해주고 사용하면, 클릭과 엔터기능을 모두 구현할 수 있다.
