# 블록레벨 스코프, 함수레벨 스코프

자바스크립트의 var는 함수레벨스코프를 갖고있다. 따라서, 다른 프로그래밍언어처럼 정교하지 못하다.

블록레벨 스코프를 위해 도입된 let과 const선언문을 사용해서 더 정교한 프로그래밍을 하자.

# 상위 스코프

- 함수가 호출되는 시점에 결정
  -> 동적 스코프

- 함수가 정의되는 시점에 결정
  -> 정적 스코프(===렉시컬 스코프)
  (자바스크립트의 특징)

자바스크립트의 함수가 정의되는 시점에 상위스코프가 결정이 되고,

해당 함수에 의해 함수 객체가 생성이 되면, 해당 함수 객체는 본인의 상위 스코프를 항상 알 수 있게 된다.
-> 자바스크립트의 함수는 태어나면서 자신의 내부 슬로세 상위스코프의 참조를 저장하기 때문이다.

함수 호출 -> 실행 컨텍스트 생성 -> 실행 컨텍스트 스택에 추가-> 렉시컬 환경 생성 -> 코드 실행이 끝나면, 실행 컨텍스트 스택을 pop하여 제거한다.

# 클로져

실행 컨텍스트가 끝난 외부함수를 참조하는 내부함수

```jsx
const x = 1;

function outer() {
  const x = 10;
  const inner = function () {
    console.log(x);
  };
  return inner;
}

const hun = outer();
hun(); // 10
```

중첩 함수

- 상위 스코프의 식별자를 참조하고 있고
- 본인의 외부 함수보다 더 오래 살아있다면..
  -> 클로져

# MVC ?

"유지보수"가 편해지는 코드 구성 방식

Model : 데이터와 관련된 부분
View: 사용자한테 보여지는 부분
Controller : Model과 View를 이어주는 부분

5가지 규칙.

1. Model은 Controller와 View에 의존하지 않아야 한다.
   (Model 내부에 Controller와 View에 관련된 코드가 있으면 안 된다.)

2. View는 Model에만 의존해야 하고, Controller에는 의존하면 안 된다.
   (View 내부에 Model의 코드만 있을 수 있고, Controller의 코드가 있으면 안 된다.)

3. View가 Model로부터 데이터를 받을 때는, 사용자마다 다르게 보여주어야 하는 데이터에 대해서만 받아야 한다.

4. Controller는 Model과 View에 의존해도 된다.
   (Controller내부에는 Model과 View의 코드가 있을 수 있다.)

5. View과 Model로부터 데이터를 받을 때, 반드시 Controller에서 받아야 한다.
